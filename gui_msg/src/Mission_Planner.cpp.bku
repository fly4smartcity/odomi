#include "ros/ros.h"
#include "gui_msg/getCurrentPosition.h"
#include "gui_msg/Drone.h"

// http://answers.ros.org/question/10905/can-a-node-act-as-a-server-and-a-publisher/
// 
bool catchTarget(gui_msg::getCurrentPosition::Request  &req,
         	 gui_msg::getCurrentPosition::Response &res)
{
  //var di interpolazione per il numero di punti
  int k=5;
  //coordinate GPS home
  float GpsLatHome=45.05;
  float GpsLngHome=7.64;
  float GpsLatGoal=(float)req.latitude;
  float GpsLngGoal=(float)req.longitude;
  
  //valore target letto
  ROS_INFO("request: latitude=%f, longitude=%f", GpsLatGoal, GpsLngGoal);
  if (true){
    //Publisher path
    res.res=true;
    //nodehandle
    ros::NodeHandle n;
    //istanzio il topic nel nodehandle
    ros::Publisher ROSGUI_drone = n.advertise<gui_msg::Drone>("drone", 1000);
    //frequenza di lavoro
    ros::Rate loop_rate(1);
    gui_msg::Drone msg;//istanzio il messaggio

    


    int i=0;
    int c;
    while (ros::ok() && i<=0)//ne invio 2 perche' il primo lo perdo sempre
    {
      ROS_INFO("Inizio a riempire il vettore");
      //CREO IL PATH
      for(c=0;c<=k;++c)
      {
        gui_msg::GpsPoint point;//istanzio il punto
        point.latitude=GpsLatHome+(((GpsLatGoal-GpsLatHome)/(k))*(k-(k-c)));
        point.longitude=GpsLngHome+(((GpsLngGoal-GpsLngHome)/(k))*(k-(k-c)));
        point.altitude=0;
        //lo inserisco nel vettore
        msg.gps_waypoint.push_back(point);
        ROS_INFO("Posizione %2d:\n\tlatitude: %f\n\tlongitude: %f",c,point.latitude,point.longitude);
      }
      //pubblico il path di punti sul topic
      ROSGUI_drone.publish(msg);
      
    
      //STAMPO quello inviato    
      //ROS_INFO("\nGPSLATHOME:\t%f\nGPSLNGHOME:\t%f\nGPSLATP1:\t%f\nGPSLNGP1:\t%f\nGPSLATP2:\t%f\nGPSLNGP2:\t%f\nGPSLATP3:\t%f\nGPSLNGP3:\t%f\nGPSLATP4:\t%f\nGPSLNGP4:\t%f\nGPSLATP5:\t%f\nGPSLNGP5:\t%f\nGPSLATPGOAL:\t%f\nGPSLNGPGOAL:\t%f",msg.GPSLATHOME,msg.GPSLNGHOME,msg.GPSLATP1,msg.GPSLNGP1,msg.GPSLATP2,msg.GPSLNGP2,msg.GPSLATP3,msg.GPSLNGP3,msg.GPSLATP4, msg.GPSLNGP4,msg.GPSLATP5,msg.GPSLNGP5,msg.GPSLATGOAL,msg.GPSLNGGOAL);
      ros::spinOnce();
      loop_rate.sleep();
      i++;
    }
    
  }
  else
    res.res=false;
  ROS_INFO("sending back response: [%d]", res.res);
  return true;
}

int main(int argc, char **argv)
{
  ros::init(argc, argv, "Mission_Planner");
  ros::NodeHandle n;

  ros::ServiceServer service = n.advertiseService("target", catchTarget);
  ROS_INFO("Ready to catch targets.");
  ros::spin();

  return 0;
}
